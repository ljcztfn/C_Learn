#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>

#define N 10

//void bubble_sort(int arr[], int n);
//void selection_sort(int arr[], int n);
void insertion_sort(int arr[], int n);
//void shell_sort(int arr[], int n);
//void merge_sort(int arr[], int n);
//void quick_sort(int arr[], int n);
//void heap_sort(int arr[], int n);

int main(void) {
	int arr[N] = { 5, 8, 7, 1, 2, 0, 4, 9, 6, 3 };
	// bubble_sort(arr, N);
	// selection_sort(arr, N);
	 insertion_sort(arr, N);
	// shell_sort(arr, N);
	// merge_sort(arr, N);
	// quick_sort(arr, N);
	//heap_sort(arr, N);

	return 0;
}

void swap(int arr[], int i, int j) {
	int temp = arr[i];
	arr[i] = arr[j];
	arr[j] = temp;
}

void print_arr(int arr[], int n) {
	for (int i = 0; i < n; i++) {
		printf("%d ", arr[i]);
	}
	printf("\n");
}


///*****************************************************/
///*				冒泡排序								 */
///*****************************************************/
//void bubble_sort(int arr[], int n) {
//	// i表示冒泡的次数
//	for (int i = 1; i < N; i++) {
//		bool isSorted = true;
//		for (int j = 0; j < N - i; j++) {
//			if (arr[j] > arr[j + 1]) { // 不能写成 >=
//				swap(arr, j, j + 1);
//				isSorted = false;
//			}
//		}
//		// 冒泡之后，判断isSorted
//		if (isSorted) return;
//		// print_arr(arr, n);
//	}
//}
//
///*****************************************************/
///*				选择排序								 */
///*****************************************************/
//void selection_sort(int arr[], int n) {
//	for (int i = 1; i < n; i++) {
//		int minIndex = i - 1;
//		for (int j = i; j < N; j++) {
//			// 更新索引
//			if (arr[j] < arr[minIndex]) {
//				minIndex = j;
//			}
//		}
//		// 交换i-1和minIndex所在位置的元素
//		swap(arr, i - 1, minIndex);
//		print_arr(arr, n);
//	}
//}
//
///*****************************************************/
///*				插入排序								 */
///*****************************************************/
void insertion_sort(int arr[], int n) {
	// i 代表无序区的第一个元素
	for (int i = 1; i < n; i++) {
		int val = arr[i];
		int j = i - 1; 
		while (j >= 0 && arr[j] > val) {
			arr[j + 1] = arr[j];
			j--;
		}
		// j == -1 || arr[j] <= val
		arr[j + 1] = val;
		print_arr(arr, n);
	}
}

///*****************************************************/
///*				希尔排序								 */
///*****************************************************/
//
//void shell_sort(int arr[], int n) {
//	int gap = n / 2;
//	while (gap != 0) {
//		// 组内插入排序
//		for (int i = gap; i < n; i++) {
//			int val = arr[i];
//			int j = i - gap;
//			while (j >= 0 && arr[j] > val) {
//				arr[j + gap] = arr[j];
//				j -= gap;
//			}
//			arr[j + gap] = val;
//		}
//		// 缩小增量
//		gap /= 2;
//		print_arr(arr, n);
//	}
//}
//
///*****************************************************/
///*				归并排序								 */
///*****************************************************/
//
//void merge(int arr[], int left, int mid, int right) {
//	int len = right - left + 1;
//	int* temp = (int*)malloc(len * sizeof(int));
//	if (temp == NULL) {
//		printf("Error: malloc failed in merge.\n");
//		exit(1);
//	}
//	int i = left, j = mid + 1, k = 0;
//	while (i <= mid && j <= right) {
//		if (arr[i] <= arr[j]) { // 不能写成 <
//			temp[k++] = arr[i++];
//		}
//		else {
//			temp[k++] = arr[j++];
//		}
//	}
//	while (i <= mid) {
//		temp[k++] = arr[i++];
//	}
//	while (j <= right) {
//		temp[k++] = arr[j++];
//	}
//	// 复制数据
//	for (int i = 0; i < len; i++) {
//		arr[left + i] = temp[i];
//	}
//	// 释放
//	free(temp);
//}
//
//void merge_sort1(int arr[], int left, int right) {
//	// 边界条件
//	if (left >= right) return;
//	int mid = left + (right - left >> 1);
//	// 对左半区间排序
//	merge_sort1(arr, left, mid);
//	// 对右半区间排序
//	merge_sort1(arr, mid + 1, right);
//	// 合并两个区间
//	merge(arr, left, mid, right);
//
//	print_arr(arr, N);
//}
//
//void merge_sort(int arr[], int n) {
//	merge_sort1(arr, 0, n - 1);
//}
//
///*****************************************************/
///*				快速排序								 */
///*****************************************************/
//
//int partition(int arr[], int left, int right) {
//	int pivot = arr[left];
//	int i = left, j = right;
//	while (i < j) {
//		while (i < j && arr[j] >= pivot) {
//			j--;
//		}
//		// i == j || arr[j] < pivot
//		arr[i] = arr[j];
//		while (i < j && arr[i] <= pivot) {
//			i++;
//		}
//		arr[j] = arr[i];
//	}
//	// i == j
//	arr[i] = pivot;
//
//	print_arr(arr, N);
//	return i;
//}
//
//void quick_sort1(int arr[], int left, int right) {
//	// 边界条件
//	if (left >= right) return;
//	// idx 为基准值的索引
//	int idx = partition(arr, left, right);
//	quick_sort1(arr, left, idx - 1);
//	quick_sort1(arr, idx + 1, right);
//}
//
//void quick_sort(int arr[], int n) {
//	quick_sort1(arr, 0, n - 1);
//}
//
//
///*****************************************************/
///*				堆排序								 */
///*****************************************************/
//
//void heapify(int arr[], int i, int len) {
//	// i 表示可能违反大顶堆规则结点的索引, len表示大顶堆包含元素的个数
//	while (i < len) {
//		int leftChild = 2 * i + 1;
//		int rightChild = 2 * i + 2;
//		int maxIdx = i;
//		if (leftChild < len && arr[leftChild] > arr[maxIdx]) {
//			maxIdx = leftChild;
//		}
//		if (rightChild < len && arr[rightChild] > arr[maxIdx]) {
//			maxIdx = rightChild;
//		}
//		if (maxIdx == i) {
//			break;
//		}
//		swap(arr, i, maxIdx);
//		i = maxIdx;
//	}
//}
//
//// 2i + 1 <= n - 1 --> i <= (n-2)/2
//void build_heap(int arr[], int n) {
//	for (int i = (n - 2) / 2; i >= 0; i--) {
//		heapify(arr, i, n);
//	}
//}
//
//void heap_sort(int arr[], int n) {
//	// 构建大顶堆
//	build_heap(arr, n);
//	printf("build_heap: ");
//	print_arr(arr, n);
//	// 无序区的长度
//	int len = n;
//	while (len > 1) {
//		swap(arr, 0, len - 1);
//		len--;
//		print_arr(arr, n);
//		// 把无序区重新调整成大顶堆
//		heapify(arr, 0, len);
//	}
//}